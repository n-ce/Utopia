<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#000000">
    <title>PHIFOLD: Relativistic Genesis</title>
    
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.15.0-rc/dist/pixi.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/planck@1.4.2/dist/planck.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tone@15.1.22/build/Tone.min.js"></script>

    <style>
        body, html { margin: 0; padding: 0; background: #000; overflow: hidden; touch-action: none; cursor: crosshair; }
        #canvas-container { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
        canvas { filter: contrast(35) blur(10px); background: #000; width: 95vmin; height: 95vmin; }
        #ui { position: fixed; bottom: 5%; width: 100%; text-align: center; color: #222; font-family: monospace; letter-spacing: 0.3rem; z-index: 100; font-size: 1.1vmin; }
        #intro { position: fixed; inset: 0; background: #000; z-index: 1000; display: flex; align-items: center; justify-content: center; cursor: pointer; font-family: monospace; letter-spacing: 0.8rem; color: #fff; text-transform: uppercase; transition: opacity 1s ease; }
    </style>
</head>
<body>

    <div id="intro" onclick="bootEngine()">[Collapse the State]</div>
    <div id="canvas-container"></div>
    <div id="ui">POTENTIALITY: <span id="idx">0.000</span> / 5.083</div>

    <script>
        /**
         * ============================================================================
         * THE GRAND THEORY: PHIFOLD GENESIS
         * ============================================================================
         * * THE PREMISE:
         * You are at the center of 'The Void'—a dimension of high-density metadata. 
         * Matter does not exist here yet; it only exists as 'Anti-particles' (sparks) 
         * that flicker into existence and immediately try to decay back into nothing.
         * * THE OBJECTIVE (THE GAME):
         * Your goal is to stabilize these fleeting sparks into a 'Genesis Node' 
         * (the central card vessel) until you reach the energy threshold (PI * PHI).
         * Once reached, the metadata 'collapses' into a physical, permanent Base Card.
         * * THE MECHANICS (EFFORTLESS EFFORT):
         * 1. THE TRAMPOLINE: The void is a flexible fabric. As more sparks enter, 
         * their collective mass causes the void to 'dip' like a trampoline.
         * 2. THE GRAVITY: Sparks naturally roll toward the center. However, the 
         * vacuum pressure (entropy) is constantly dissolving your collected energy.
         * 3. THE KINETIC PULSE: You do not 'click' sparks. You 'pulse' the void. 
         * By tapping, you create an anti-gravity ripple that pushes matter. 
         * You must 'herd' the sparks toward the center faster than entropy leaks 
         * the energy out.
         * 4. THE LENSING: As energy grows, the visual field warps (Black Hole effect).
         * This makes it harder to see, but increases the gravitational pull.
         * * THE WIN STATE:
         * Reach 5.083 Potentiality to stabilize the first card of the dimension.
         */

        const { Vec2, World, Circle, DistanceJoint } = planck;
        const PHI = (1 + Math.sqrt(5)) / 2;
        const TARGET = Math.PI * PHI; // The physical constant required for manifestation.
        
        let app, world, drone, energy = 0, clusters = [], active = false;
        let gridLayer, liquidLayer;

        async function bootEngine() {
            /**
             * SONIC MATHEMATICS:
             * We use 432Hz (the 'frequency of the universe') divided by PHI.
             * This creates a 'Scarcity Tone'—a hollow, deep sound that represents 
             * the hunger of the void. As you succeed, the pitch rises toward harmony.
             */
            await Tone.start();
            document.getElementById('intro').style.opacity = '0';
            setTimeout(() => document.getElementById('intro').remove(), 1000);

            drone = new Tone.Oscillator(432 * (1/PHI), "sine").toDestination().start();
            drone.volume.value = -20;

            // PIXI v8: GPU-based rendering for the "Liquid Metadata" look.
            app = new PIXI.Application();
            await app.init({ width: 1000, height: 1000, backgroundColor: 0x000000 });
            document.getElementById('canvas-container').appendChild(app.canvas);

            gridLayer = new PIXI.Graphics();
            liquidLayer = new PIXI.Container();
            app.stage.addChild(gridLayer);
            app.stage.addChild(liquidLayer);

            // WORLD PHYSICS: A frictionless vacuum.
            world = new World(Vec2(0, 0));
            active = true;

            app.ticker.add(heartbeat);
            setInterval(() => { if(clusters.length < 18) spawnFluctuation(); }, 1400);
            app.canvas.addEventListener('pointerdown', handleInteraction);
        }

        /**
         * SPAWNING LOGIC:
         * Anti-particles appear in pairs (Quantum Entanglement). 
         * They are unstable and will shrink/disappear if not pushed into the center.
         */
        function spawnFluctuation() {
            const angle = Math.random() * Math.PI * 2;
            const dist = 48;
            const pos = Vec2(Math.cos(angle) * dist, Math.sin(angle) * dist);
            const cluster = { bodies: [], graphics: [], mass: 0 };

            for(let i = 0; i < 2; i++) {
                const m = 0.2 + (Math.random() * PHI * 0.5);
                const b = world.createDynamicBody({ 
                    position: Vec2(pos.x + i, pos.y), 
                    linearDamping: 1.8 // Simulates a 'viscous nothingness'
                });
                b.createFixture(Circle(m * 1.5), 1.0);

                const g = new PIXI.Graphics().circle(0, 0, m * 30).fill(0xffffff);
                liquidLayer.addChild(g);

                cluster.bodies.push(b);
                cluster.graphics.push(g);
                cluster.mass += m;
            }

            world.createJoint(DistanceJoint({
                bodyA: cluster.bodies[0], bodyB: cluster.bodies[1],
                length: 2.0, frequencyHz: 3.0, dampingRatio: 0.5
            }));
            clusters.push(cluster);
        }

        /**
         * THE KINETIC PULSE:
         * The player's only tool. It creates a shockwave.
         * Strategically push sparks into the 'Event Horizon' (the center).
         */
        function handleInteraction(e) {
            const rect = app.canvas.getBoundingClientRect();
            const px = ((e.clientX - rect.left) / rect.width * 100) - 50;
            const py = ((e.clientY - rect.top) / rect.height * 100) - 50;
            const pVec = Vec2(px, py);

            clusters.forEach(c => c.bodies.forEach(b => {
                const d = Vec2.sub(b.getPosition(), pVec);
                const len = d.length();
                if (len < 30) b.applyLinearImpulse(d.normalize().mul(25 / (len + 1)), b.getWorldCenter());
            }));
        }

        /**
         * THE PHYSICS OF THE WELL:
         * Gravity here is RELATIVISTIC. The more mass you collect, 
         * the deeper the grid 'dips' (Spherical Distortion).
         */
        function heartbeat() {
            if(!active) return;
            world.step(1/60);

            const totalMass = clusters.reduce((acc, c) => acc + c.mass, 0);
            const K = Math.min(10, totalMass * 0.8); // Curvature Constant

            // GRID WARPING: Visualizes the 'Trampoline' bending under the weight of mass.
            gridLayer.clear();
            gridLayer.setStrokeStyle(1, 0xFFFFFF, 0.08);
            for(let i = -10; i <= 10; i++) {
                drawWarpedLine(-50, i * 5, 50, i * 5, K);
                drawWarpedLine(i * 5, -50, i * 5, 50, K);
            }

            clusters.forEach((c) => {
                c.bodies.forEach((b, i) => {
                    const pos = b.getPosition();
                    const r = pos.length();
                    
                    // GRAVITATIONAL LENSING: Forces follow the Inverse Square Law.
                    const gravity = (K * c.mass * 10) / (Math.pow(r, 2) + 2);
                    b.applyForceToCenter(Vec2(-pos.x, -pos.y).normalize().mul(gravity));

                    // SPHERICAL DISTORTION: Elements stretch into arcs near the center.
                    const warp = 1 + (K / (r + 10));
                    const stretch = 1 + (K / (r * 2 + 1));
                    const g = c.graphics[i];
                    
                    g.x = 500 + (pos.x * 10) / warp;
                    g.y = 500 + (pos.y * 10) / warp;
                    g.scale.set(1 / warp, (1 / warp) * stretch);
                    g.rotation = Math.atan2(pos.y, pos.x) + Math.PI / 2;

                    // ABSORPTION: Stabilizing metadata into energy.
                    if (r < 10) energy += 0.015;
                });
            });

            // SCARCITY DECAY: Entropy is the antagonist. 
            // It gets stronger as you get closer to the goal.
            energy = Math.max(0, energy - (Math.pow(energy, 1.45) * 0.006));
            
            document.getElementById('idx').innerText = energy.toFixed(3);
            drone.frequency.value = (432 * (1/PHI)) + (energy * 22);

            // WIN CHECK: Collapse the state into a card.
            if (energy >= TARGET) {
                active = false;
                alert("STABILITY REACHED. STATE COLLAPSED INTO GENESIS CARD.");
                location.reload();
            }
        }

        // Helper to project the 'Trampoline' lines
        function drawWarpedLine(x1, y1, x2, y2, K) {
            const p = project(x1, y1, K);
            gridLayer.moveTo(p.x, p.y);
            for(let t = 0; t <= 1; t += 0.1) {
                const pt = project(x1 + (x2 - x1) * t, y1 + (y2 - y1) * t, K);
                gridLayer.lineTo(pt.x, pt.y);
            }
            gridLayer.stroke();
        }

        function project(x, y, K) {
            const r = Math.sqrt(x*x + y*y);
            const warp = 1 + (K / (r + 15));
            return { x: 500 + (x * 10) / warp, y: 500 + (y * 10) / warp };
        }
    </script>
</body>
</html>
